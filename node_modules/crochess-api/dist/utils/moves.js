import { calcDistance, toXY } from './helpers';
import Piece from '../Piece';
const moves = {
    vertAndLateral: (from) => (to) => {
        const [x1, y1] = from.split('');
        const [x2, y2] = to.split('');
        return x1 === x2 || y1 === y2;
    },
    diagonal: (from) => (to) => {
        const { x: x1, y: y1 } = toXY(from);
        const { x: x2, y: y2 } = toXY(to);
        return Math.abs(x2 - x1) === Math.abs(y2 - y1);
    },
    xByN: (num) => (from) => (to) => {
        const { x: x1 } = toXY(from);
        const { x: x2 } = toXY(to);
        return Math.abs(x1 - x2) === num;
    },
    yByN: (num) => (from) => (to) => {
        const { y: y1 } = toXY(from);
        const { y: y2 } = toXY(to);
        return Math.abs(y1 - y2) === num;
    }
};
export default moves;
/* dealing with move vectors */
function splitIntoVectors(arrayOfMoves, start) {
    return arrayOfMoves.reduce((acc, curr) => {
        const { xDiff, yDiff } = calcDistance(start)(curr);
        let vector = '';
        if (yDiff !== 0)
            vector = yDiff < 0 ? 'up' : 'down';
        if (xDiff !== 0)
            vector += xDiff < 0 ? 'Right' : 'Left';
        // normalize vector name
        vector = vector.charAt(0).toLowerCase() + vector.slice(1);
        acc[vector] = acc[vector] || [];
        acc[vector].push(curr);
        return acc;
    }, {});
}
function getBeginningOfVector(vector) {
    if (vector.length === 0)
        return '';
    return vector.reduce((acc, curr) => {
        const { x: x1, y: y1 } = toXY(acc);
        const { x: x2, y: y2 } = toXY(curr);
        const accIsBeginning = x1 === x2 ? y1 < y2 : x1 < x2;
        return accIsBeginning ? acc : curr;
    });
}
const getMovesAlongVector = (s1, s2, allSquares) => {
    const liesSameVertOrLat = moves.vertAndLateral(s1)(s2);
    const liesSameDiagonally = moves.diagonal(s1)(s2);
    const liesOnSameLine = liesSameVertOrLat || liesSameDiagonally;
    if (!liesOnSameLine)
        return [];
    const matchingVector = liesSameDiagonally ? 'diagonal' : 'vertAndLateral';
    const squaresAlongVector = allSquares.filter((s) => moves[matchingVector](s1)(s) && moves[matchingVector](s2)(s));
    return squaresAlongVector;
};
/* sort moves */
const sortMovesClosestTo = (square) => (moves) => {
    return [...moves].sort((a, b) => {
        const { xDiff: x1Diff, yDiff: y1Diff } = calcDistance(square)(a);
        const aDiff = Math.abs(x1Diff) + Math.abs(y1Diff);
        const { xDiff: x2Diff, yDiff: y2Diff } = calcDistance(square)(b);
        const bDiff = Math.abs(x2Diff) + Math.abs(y2Diff);
        return aDiff - bDiff;
    });
};
/* get moves */
function getPossibleMoves(origin, board) {
    // get all moves that can happen if no other pieces were on the board
    const allSquares = Array.from(board.keys());
    const square = board.get(origin);
    const { type, color } = square.piece;
    const piece = Piece(color, type);
    return allSquares.filter((s) => piece.hasMove(origin, s));
}
function getLegalMoves(origin, board) {
    // get moves regardless of whether or not there is check
    const square = board.get(origin);
    const piece = square.piece;
    const possibleMoves = getPossibleMoves(origin, board);
    const obstructions = possibleMoves.filter((s) => { var _a; return (_a = board.get(s)) === null || _a === void 0 ? void 0 : _a.piece; });
    if (!obstructions.length) {
        if (piece.type === 'pawn')
            return [...getPawnCaptures(origin, board), ...possibleMoves];
        return possibleMoves;
    }
    let legalMoves = [];
    switch (piece.type) {
        case 'knight': {
            legalMoves = possibleMoves;
            break;
        }
        case 'pawn': {
            const capturesAvailable = getPawnCaptures(origin, board);
            const unobstructedMoves = removeMovesWithPieces(removeObstructedMoves(origin, possibleMoves, obstructions), board);
            legalMoves = [...capturesAvailable, ...unobstructedMoves];
            break;
        }
        case 'king': {
            legalMoves = removeProtectedSquares(origin, possibleMoves, board);
            break;
        }
        default: {
            legalMoves = removeObstructedMoves(origin, possibleMoves, obstructions);
        }
    }
    return removeMovesWithPieces(legalMoves, board, piece.color);
}
function getLegalMovesInCheck(origin, board, kingPos, squareGivingCheck) {
    const squaresThatDealWithCheck = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys()));
    const moves = getLegalMoves(origin, board);
    return moves.filter((s) => squaresThatDealWithCheck.includes(s));
}
function getAttackingMoves(origin, board) {
    const square = board.get(origin);
    const { type, color } = square.piece;
    switch (type) {
        case 'pawn': {
            const piece = Piece(color, 'pawn');
            return piece.getPawnCaptures(origin);
        }
        case 'king': {
            // need to do this because getLegalMoves will recursively call removeProtectedSquares otherwise
            const attackingMoves = removeMovesWithPieces(getPossibleMoves(origin, board), board, color);
            return attackingMoves;
        }
        default:
            return getLegalMoves(origin, board);
    }
}
function getAllMovesForColor(color, board, skipKing) {
    const allMoves = [];
    for (const [square, { piece }] of board.entries()) {
        if (!piece)
            continue;
        if (piece.color !== color)
            continue;
        if (skipKing && piece.type === 'king')
            continue;
        allMoves.push(getLegalMoves(square, board));
    }
    return allMoves.flat();
}
function getAttackingMovesForColor(color, board) {
    const allMoves = [];
    for (const [square, { piece }] of board.entries()) {
        if (!piece)
            continue;
        if (piece.color !== color)
            continue;
        allMoves.push(getAttackingMoves(square, board));
    }
    return allMoves.flat();
}
function getPawnCaptures(pawnSquare, board) {
    var _a;
    const { color } = (_a = board.get(pawnSquare)) === null || _a === void 0 ? void 0 : _a.piece;
    const pawn = Piece(color, 'pawn');
    const captureMoves = pawn.getPawnCaptures(pawnSquare);
    if (!captureMoves)
        return [];
    return captureMoves.filter((s) => {
        const squareVal = board.get(s);
        if (!squareVal)
            return false;
        const piece = squareVal.piece;
        const enPassant = squareVal.enPassant;
        return ((piece && piece.color !== pawn.color) ||
            (enPassant && enPassant.color !== pawn.color));
    });
}
function getSquaresBetweenKingAndCheck(kingPos, checkPos, allSquares) {
    // includes kingPos and checkPos
    const squaresAlongVector = getMovesAlongVector(kingPos, checkPos, allSquares);
    const squaresBetweenKingAndPiece = removeMovesBehindTwoSquares(kingPos, checkPos, squaresAlongVector);
    return squaresBetweenKingAndPiece;
}
/* filter moves */
function removeMovesBehindTwoSquares(s1, s2, vector) {
    const sorted = sortMovesClosestTo(getBeginningOfVector(vector))(vector);
    let furthestSquare;
    let closestSquare;
    if (sorted.indexOf(s1) > sorted.indexOf(s2)) {
        furthestSquare = s1;
        closestSquare = s2;
    }
    else {
        furthestSquare = s2;
        closestSquare = s1;
    }
    const removedOneEnd = removeMovesBehindSquare(furthestSquare)(sorted);
    const removedBothEnds = removeMovesBehindSquare(closestSquare)(removedOneEnd.reverse());
    return removedBothEnds;
}
const removeMovesBehindSquare = (square) => (moves) => {
    const copy = [...moves];
    const index = moves.indexOf(square);
    if (index === -1)
        return [];
    copy.splice(index + 1);
    return copy;
};
function removeObstructedMoves(startingSquare, possibleMoves, obstructions) {
    // a) split possible moves into vectors (up,down,left,right, and/or diagonals)
    // b) see which obstructions belong to which vector
    // c) find the closest obstruction
    // d) remove all the moves behind that obstruction
    const filteredMoves = [];
    const allVectors = splitIntoVectors(possibleMoves, startingSquare);
    const obstructionVectors = splitIntoVectors(obstructions, startingSquare);
    for (const vector in allVectors) {
        if (!obstructionVectors[vector]) {
            // look for vector obstruction is on
            filteredMoves.push(allVectors[vector]);
            continue;
        }
        const sorted = sortMovesClosestTo(startingSquare)(allVectors[vector]);
        const closestObstruction = sortMovesClosestTo(startingSquare)(obstructionVectors[vector])[0];
        filteredMoves.push(removeMovesBehindSquare(closestObstruction)(sorted));
    }
    return filteredMoves.flat();
}
function removeProtectedSquares(kingPos, possibleMoves, board) {
    var _a;
    const king = (_a = board.get(kingPos)) === null || _a === void 0 ? void 0 : _a.piece;
    const oppColor = king.color === 'white' ? 'black' : 'white';
    const enemyPiecesInVicinity = possibleMoves.filter((s) => { var _a, _b; return ((_b = (_a = board.get(s)) === null || _a === void 0 ? void 0 : _a.piece) === null || _b === void 0 ? void 0 : _b.color) === oppColor; });
    const squaresProtectedByEnemyInVicinity = enemyPiecesInVicinity
        .map((s) => getAttackingMoves(s, board))
        .flat();
    // bc king cant move if square is protected
    // set king piece on each square in possible moves to find which squares are protected
    const boardCopy = new Map(board);
    possibleMoves.forEach((s) => boardCopy.set(s, { piece: king }));
    const squaresProtectedByRange = getAttackingMovesForColor(oppColor, boardCopy);
    return possibleMoves.filter((s) => {
        return (!squaresProtectedByRange.includes(s) &&
            !squaresProtectedByEnemyInVicinity.includes(s));
    });
}
function removeMovesWithPieces(moves, board, color) {
    return moves.filter((s) => {
        const squareVal = board.get(s);
        if (!squareVal)
            return false;
        if (color)
            return !squareVal.piece || squareVal.piece.color !== color;
        else
            return !squareVal.piece;
    });
}
/* gameboard checks */
function getDiscoveredCheck(kingPos, kingColor, vacated, board) {
    var _a;
    // openSquare is a square just vacated
    let squaresAlongVector = getMovesAlongVector(kingPos, vacated, Array.from(board.keys()));
    squaresAlongVector = squaresAlongVector.filter((s) => s !== kingPos && s !== vacated);
    if (!squaresAlongVector.length)
        return '';
    for (const square of squaresAlongVector) {
        const piece = (_a = board.get(square)) === null || _a === void 0 ? void 0 : _a.piece;
        if (!piece || piece.color === kingColor)
            continue;
        const legalMoves = getLegalMoves(square, board);
        if (legalMoves.includes(kingPos))
            return square;
    }
    return '';
}
function canBlockOrCaptureCheck(kingPos, squareGivingCheck, board) {
    var _a;
    const king = (_a = board.get(kingPos)) === null || _a === void 0 ? void 0 : _a.piece;
    const blockOrCaptureSquares = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys())); // also includes check square
    const ownPieceMoves = getAllMovesForColor(king.color, board, true);
    return ownPieceMoves.some((move) => blockOrCaptureSquares.includes(move));
}
function getPiecesWithMove(board, move, pieceType, color) {
    const pieceSquares = [];
    for (const [square, { piece }] of board.entries()) {
        if (!piece)
            continue;
        if (piece.color !== color)
            continue;
        if (piece.type !== pieceType)
            continue;
    }
}
export { getAttackingMovesForColor, getLegalMoves, getLegalMovesInCheck, getDiscoveredCheck, canBlockOrCaptureCheck };
//# sourceMappingURL=moves.js.map