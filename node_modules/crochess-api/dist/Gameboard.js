import { getLegalMoves, getDiscoveredCheck, canBlockOrCaptureCheck, getAttackingMovesForColor, getLegalMovesInCheck } from './utils/moves';
import { toXY, fromXY, parseNotation } from './utils/helpers';
import { ranks, files } from './ranksAndFiles';
import Castle from './Castle';
import { startingPositions } from './main';
import moveNotation from './moveNotation';
import Piece from './Piece';
function createBoard() {
    return files.reduce((acc, file) => {
        ranks.forEach((rank) => {
            const square = file.concat(rank.toString());
            acc.set(square, { piece: null });
        });
        return acc;
    }, new Map());
}
const Gameboard = (board = createBoard(), squaresGivingCheck, CastleRights) => {
    board = new Map(board);
    function placePieces(pieceMap, boardMap = board) {
        let color;
        for (color in pieceMap) {
            const map = pieceMap[color];
            let pieceType;
            for (pieceType in map) {
                const squares = map[pieceType];
                squares.forEach((s) => at(s, boardMap).place({ type: pieceType, color: color }));
            }
        }
    }
    function makeMove(s1, s2, promote) {
        const piece = at(s1).piece;
        // validate move
        if (!piece)
            return;
        if (!validate.move(s1, s2))
            return;
        if (promote && !validate.promotion(s1, s2))
            return;
        switch (piece.type) {
            case 'pawn': {
                if (promote) {
                    at(s1).promote(promote);
                }
                if (enPassant.isCapture(s1, s2)) {
                    enPassant.capture(s2);
                }
                enPassant.remove();
                if (enPassant.checkToggle(s1, s2)) {
                    enPassant.toggle(piece.color, s2);
                }
                from(s1).to(s2);
                break;
            }
            case 'king': {
                // check if move is castle
                const castleSide = get.castleSide(piece.color, s2);
                if (castleSide)
                    castle(piece.color, castleSide);
                else
                    from(s1).to(s2);
                enPassant.remove();
                break;
            }
            default:
                from(s1).to(s2);
                enPassant.remove();
        }
        return board;
    }
    function castle(color, side, boardMap = board) {
        const castleSquares = get.castleSquares(color)[side];
        const kingPos = get.kingPosition(color, boardMap);
        const rookPos = getRookPos();
        from(rookPos, boardMap).to(castleSquares[0]);
        from(kingPos, boardMap).to(castleSquares[1]);
        function getRookPos() {
            const pieceMap = get.pieceMap(boardMap);
            const rookPos = pieceMap[color].rook.find((square) => {
                const file = square.split('')[0];
                return side === 'kingside'
                    ? files.indexOf(file) > 3
                    : files.indexOf(file) < 3;
            });
            return rookPos;
        }
        // need to get king position
        // need to get castle squares
        // need to find rook
    }
    const enPassant = (() => {
        function getSquare(current, color) {
            const { x, y } = toXY(current);
            const newY = color === 'white' ? y - 1 : y + 1;
            return fromXY({ x, y: newY });
        }
        return {
            checkToggle: (from, to) => {
                const { y: y1 } = toXY(from);
                const { y: y2 } = toXY(to);
                return Math.abs(y1 - y2) === 2;
            },
            toggle: (color, current, boardMap = board) => {
                const enPassantSquare = getSquare(current, color);
                at(enPassantSquare, boardMap).setEnPassant(color, current);
            },
            remove: (boardMap = board) => {
                for (const squareObj of boardMap.values()) {
                    if (squareObj.enPassant)
                        return (squareObj.enPassant = undefined);
                }
            },
            isCapture: (from, to, boardMap = board) => {
                var _a;
                const piece = at(from, boardMap).piece;
                const enPassant = (_a = boardMap.get(to)) === null || _a === void 0 ? void 0 : _a.enPassant;
                if (!piece || piece.type !== 'pawn')
                    return false;
                if (!enPassant)
                    return false;
                if (enPassant.color === piece.color)
                    return false;
                return true;
            },
            capture: (to, boardMap = board) => {
                var _a;
                const enPassant = (_a = boardMap.get(to)) === null || _a === void 0 ? void 0 : _a.enPassant;
                at(enPassant.current, boardMap).remove();
            }
        };
    })();
    const at = (square, boardMap = board) => ({
        place: (piece) => {
            if (!boardMap.get(square))
                return;
            boardMap.set(square, { piece });
        },
        remove: () => {
            if (!boardMap.get(square))
                return;
            boardMap.set(square, { piece: null });
        },
        promote: (pieceType) => {
            const squareVal = boardMap.get(square);
            const piece = squareVal === null || squareVal === void 0 ? void 0 : squareVal.piece;
            if (!piece)
                return;
            boardMap.set(square, Object.assign(Object.assign({}, squareVal), { piece: Object.assign(Object.assign({}, piece), { type: pieceType }) }));
        },
        setEnPassant: (color, current) => {
            if (!boardMap.get(square))
                return;
            boardMap.set(square, {
                piece: null,
                enPassant: {
                    current /* square pawn is on */,
                    color
                }
            });
        },
        get piece() {
            var _a;
            return (_a = boardMap.get(square)) === null || _a === void 0 ? void 0 : _a.piece;
        },
        getLegalMoves: (checks = squaresGivingCheck || []) => {
            const { type, color } = at(square, boardMap).piece;
            switch (checks.length) {
                case 2: {
                    if (type !== 'king')
                        return [];
                    return getLegalMoves(square, boardMap);
                }
                case 1: {
                    if (type === 'king')
                        return getLegalMoves(square, boardMap);
                    else
                        return getLegalMovesInCheck(square, boardMap, get.kingPosition(color), checks[0]);
                }
                default: {
                    if (type === 'king') {
                        let legalMoves = getLegalMoves(square, boardMap);
                        if (get.canCastle(color, 'kingside'))
                            legalMoves = [
                                ...legalMoves,
                                ...get.castleSquares(color).kingside
                            ];
                        if (get.canCastle(color, 'queenside'))
                            legalMoves = [
                                ...legalMoves,
                                ...get.castleSquares(color).queenside
                            ];
                        return legalMoves;
                    }
                    else
                        return getLegalMoves(square, boardMap);
                }
            }
        }
    });
    const from = (s1, boardMap = board) => ({
        to: (s2) => {
            const piece = at(s1, boardMap).piece;
            if (!piece)
                return;
            // move piece
            at(s1, boardMap).remove();
            at(s2, boardMap).place(piece);
        }
    });
    const get = {
        kingPosition: (color, boardMap = board) => {
            for (const [square, value] of boardMap.entries()) {
                if (value.piece &&
                    value.piece.type === 'king' &&
                    value.piece.color === color)
                    return square;
            }
        },
        pieceMap: (boardMap = board) => {
            const pieceMap = { white: {}, black: {} };
            for (const [square, value] of boardMap.entries()) {
                const { piece } = value;
                if (!piece)
                    continue;
                const { type, color } = piece;
                pieceMap[color][type] = pieceMap[color][type]
                    ? [...pieceMap[color][type], square]
                    : [square];
            }
            return pieceMap;
        },
        piecesThatHitSquare: (color, pieceType, square, boardMap = board) => {
            const pieceMap = get.pieceMap(boardMap);
            if (pieceMap[color][pieceType].includes(square))
                return [];
            const pieces = [];
            if (pieceMap[color][pieceType].length <= 1)
                return [];
            pieceMap[color][pieceType].forEach((s) => {
                if (at(s, boardMap).getLegalMoves().includes(square))
                    pieces.push(s);
            });
            return pieces;
        },
        squaresGivingCheckAfterMove: (from, end) => {
            var _a;
            const squaresGivingCheck = [];
            const piece = (_a = board.get(end)) === null || _a === void 0 ? void 0 : _a.piece;
            const oppColor = piece.color === 'white' ? 'black' : 'white';
            const kingPosition = get.kingPosition(oppColor);
            const pieceHitsKing = getLegalMoves(end, board).includes(kingPosition);
            if (pieceHitsKing)
                squaresGivingCheck.push(end);
            const discoveredCheck = getDiscoveredCheck(kingPosition, oppColor, from, board);
            if (discoveredCheck && discoveredCheck !== end)
                squaresGivingCheck.push(discoveredCheck);
            return squaresGivingCheck;
        },
        isCheckmate: (colorOfKing, squaresGivingCheck, boardMap = board) => {
            const kingPos = get.kingPosition(colorOfKing, boardMap);
            const legalMoves = at(kingPos, boardMap).getLegalMoves();
            // check if check can be blocked
            if (squaresGivingCheck.length === 1) {
                if (canBlockOrCaptureCheck(kingPos, squaresGivingCheck[0], boardMap))
                    return false;
            }
            if (legalMoves.length)
                return false;
            return true;
        },
        castleSquares(color) {
            const rank = color === 'white' ? 1 : 8;
            return {
                kingside: [`f${rank}`, `g${rank}`],
                queenside: [`d${rank}`, `c${rank}`]
            };
        },
        castleSide(color, to) {
            let castleSide = '';
            const castleSquares = get.castleSquares(color);
            for (const [side, squares] of Object.entries(castleSquares)) {
                if (squares[1] === to)
                    castleSide = side;
            }
            return castleSide;
        },
        castleRightsAfterMove: (square, boardMap = board) => {
            const piece = at(square, boardMap).piece;
            const castleRights = CastleRights || Castle(true, true, true, true);
            if (castleRights[piece.color].kingside ||
                castleRights[piece.color].queenside) {
                // check if i need to change castling rights
                if (piece.type === 'king') {
                    castleRights[piece.color].kingside = false;
                    castleRights[piece.color].queenside = false;
                }
                if (piece.type === 'rook') {
                    // need to find if it is kingside or queenside rook
                    const [file] = square.split('');
                    const kingside = files.indexOf(file) > 3;
                    if (kingside)
                        castleRights[piece.color].kingside = false;
                    else
                        castleRights[piece.color].queenside = false;
                }
            }
            return castleRights;
        },
        canCastle: (color, side, boardMap = board) => {
            if (CastleRights && !CastleRights[color][side])
                return false;
            // check if rook still exists
            if (!checkIfRookExists())
                return false;
            const oppColor = color === 'white' ? 'black' : 'white';
            const oppMoves = getAttackingMovesForColor(oppColor, boardMap);
            const castleSquares = get.castleSquares(color)[side];
            for (const square of castleSquares) {
                // check if castle square is cleared
                if (at(square, boardMap).piece)
                    return false;
                // make sure castle square isnt attacked
                if (oppMoves.includes(square))
                    return false;
            }
            return true;
            function checkIfRookExists() {
                let rookExists = false;
                const rank = color === 'white' ? 1 : 8;
                const loopStart = side === 'queenside' ? files.indexOf('a') : files.indexOf('d');
                const loopEnd = side === 'queenside' ? files.indexOf('e') : files.indexOf('h');
                for (let i = loopStart; i <= loopEnd; i++) {
                    const square = files[i] + rank;
                    const piece = at(square, boardMap).piece;
                    if (!piece)
                        continue;
                    if (piece.type === 'rook')
                        rookExists = true;
                }
                return rookExists;
            }
        },
        boardStateFromHistory: (history) => {
            const boardStates = [];
            const boardMap = createBoard();
            placePieces(startingPositions.standard, boardMap);
            let pieceMap = startingPositions.standard;
            // history is 2d array
            const flat = history.flat();
            /* iterate over history */
            for (const [i, m] of flat.entries()) {
                const parsed = parseNotation(m);
                const color = i % 2 === 0 ? 'white' : 'black';
                if (parsed.castle) {
                    castle(color, parsed.castle, boardMap);
                    pieceMap = get.pieceMap(boardMap);
                    boardStates.push(new Map(boardMap));
                    continue;
                }
                const possiblePieces = pieceMap[color][parsed.pieceType].filter((s) => getLegalMoves(s, boardMap).includes(parsed.to));
                // get 'from' square
                let s1;
                if (parsed.from) {
                    const notation = parsed.from;
                    if (notation.length === 2)
                        s1 = notation;
                    else {
                        s1 =
                            possiblePieces.find((s) => {
                                // if notation is a number, that means piece is on the rank === notation, if not, same file
                                return isNaN(Number(notation))
                                    ? s[0] === notation
                                    : s[1] === notation;
                            }) || '';
                    }
                }
                else
                    s1 = possiblePieces[0];
                const piece = at(s1, boardMap).piece;
                if (!s1 || !piece) {
                    break;
                }
                // make move
                if (piece.type === 'pawn') {
                    if (enPassant.isCapture(s1, parsed.to, boardMap)) {
                        enPassant.capture(parsed.to, boardMap);
                    }
                    enPassant.remove(boardMap);
                    if (enPassant.checkToggle(s1, parsed.to))
                        enPassant.toggle(color, parsed.to, boardMap);
                    if (parsed.promote) {
                        at(s1, boardMap).promote(parsed.promote);
                    }
                }
                else
                    enPassant.remove(boardMap);
                from(s1, boardMap).to(parsed.to);
                pieceMap = get.pieceMap(boardMap);
                boardStates.push(new Map(boardMap));
            }
            return boardStates;
        },
        moveNotation(from, to, promote, check, checkmate, boardMap = board) {
            var _a;
            const moveDetails = {};
            const { type, color } = at(from, boardMap).piece;
            moveDetails.pieceType = type;
            if (checkmate)
                moveDetails.checkmate = checkmate;
            else if (check)
                moveDetails.check = check;
            let capture = false;
            switch (type) {
                case 'pawn': {
                    capture = (_a = Piece(color, type)
                        .getPawnCaptures(from)) === null || _a === void 0 ? void 0 : _a.includes(to);
                    moveDetails.capture = capture;
                    if (capture)
                        moveDetails.differentiation = from[0];
                    break;
                }
                default: {
                    capture = !!at(to, boardMap).piece;
                    moveDetails.capture = capture;
                }
            }
            if (promote)
                moveDetails.promote = promote;
            // get differentiation ie. when multiple pieces hit the same square
            const piecesThatHitSquare = get.piecesThatHitSquare(color, type, to, boardMap);
            switch (piecesThatHitSquare.length) {
                case 3:
                    moveDetails.differentiation = from;
                    break;
                case 2: {
                    // need to find if on same file or rank
                    const otherPiece = piecesThatHitSquare.find((s) => s !== from);
                    moveDetails.differentiation =
                        otherPiece[0] === from[0] ? from[1] : from[0];
                }
            }
            return moveNotation(to).get(moveDetails);
        }
    };
    const validate = {
        move: (from, to, boardMap = board) => {
            const piece = at(from, boardMap).piece;
            if (!piece)
                return false;
            if (!at(from, boardMap).getLegalMoves().includes(to))
                return false;
            return true;
        },
        promotion: (from, to, boardMap = board) => {
            const piece = at(from, boardMap).piece;
            if ((piece === null || piece === void 0 ? void 0 : piece.type) !== 'pawn')
                return false;
            const endOfBoard = piece.color === 'white' ? 8 : 1;
            const [, rank] = to.split('');
            if (+rank !== endOfBoard)
                return false;
            return true;
        }
    };
    return {
        createBoard,
        placePieces,
        castle,
        enPassant,
        at,
        from,
        get,
        validate,
        makeMove,
        get board() {
            return board;
        }
    };
};
export default Gameboard;
//# sourceMappingURL=Gameboard.js.map